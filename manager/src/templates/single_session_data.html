<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Single Session Data</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="{{ url_for('static', filename='general.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='session_data.css') }}">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    .charts-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(380px, 1fr));
      gap: 40px;
      margin-top: 30px;
    }
    .chart-container {
      position: relative;
      width: 100%;
      height: 300px;
    }
    .chart-container:fullscreen {
      width: 100vw; height: 100vh; background: #fff; padding: 12px; box-sizing: border-box;
    }
  </style>
</head>

<body>
<a href="/session_data" class="home-button">
  <img src="{{ url_for('static', filename='photos/home.png') }}" alt="Home" class="home-icon">
</a>

<div class="session-container">
  <h1>Session&nbsp;ID:&nbsp;#{{ metadata.sessionId }}</h1>
  <p style="text-align:center;">
    <strong>Game&nbsp;Type:</strong>&nbsp;{{ metadata.gameType.replace('_',' ').title() }}&nbsp;|
    <strong>Duration:</strong>&nbsp;{{ metadata.duration }}&nbsp;s&nbsp;|
    <strong>Participants:</strong>&nbsp;{{ metadata.participants|join(' & ') }}
  </p>

  <div class="charts-grid">
    <div class="chart-container"><h3 style="text-align:center;">Heart Rate</h3><canvas id="hrChart"></canvas></div>
    <div class="chart-container"><h3 style="text-align:center;">HR Variation</h3><canvas id="hrvChart"></canvas></div>
    <div class="chart-container"><h3 style="text-align:center;">Latency</h3><canvas id="latencyChart"></canvas></div>
    <div class="chart-container"><h3 style="text-align:center;">Jitter</h3><canvas id="jitterChart"></canvas></div>
    <div class="chart-container"><h3 style="text-align:center;" id="gameChartTitle"></h3><canvas id="gameChart"></canvas></div>
  </div>
</div>

<script>
const meta = {{ metadata|tojson }};
const heartData = {{ data.heart|tojson }};
const hrvData = {{ data.hrv|tojson }};
const latencyData = {{ data.latency|tojson }};
const jitterData = {{ data.jitter|tojson }};
const clickEvents = {{ data.click_events|tojson }};
const syncEvents = {{ data.sync_events|tojson }};
const frequencyData = {{ data.frequency_data|tojson }};
const frequencyLabels = {{ data.frequency_labels|tojson }};
const syncIntervals = {{ data.sync_intervals|tojson }};

/* ---------- Helpers ---------- */
function makeDatasets(srcDict, labels, cfg = {}) {
  return Object.keys(srcDict).map(actor => ({
    label: actor,
    data: srcDict[actor].map((v, i) => ({ x: +labels[i], y: +v })),
    fill: false,
    tension: 0.3,
    ...cfg
  }));
}
function makeLine(chartId, labels, datasets, yTitle) {
  new Chart(chartId, {
    type: 'line',
    data: { labels: labels, datasets },
    options: { responsive: true, scales: { y: { title: { display: true, text: yTitle } } } }
  });
}
function makeBar(chartId, labels, datasets, yTitle) {
  new Chart(chartId, {
    type: 'bar',
    data: { labels: labels, datasets },
    options: { responsive: true, scales: { y: { beginAtZero: true, title: { display: true, text: yTitle } } } }
  });
}

/* ---------- Build Charts ---------- */
/* Heart Rate */
{
  const [hrData, hrLabels] = heartData;
  makeLine(hrChart, hrLabels, makeDatasets(hrData, hrLabels), 'BPM');
}

/* HRV */
{
  const [hrvDict, hrvLabels] = hrvData;
  makeLine(hrvChart, hrvLabels, makeDatasets(hrvDict, hrvLabels), 'ms');
}

/* Latency */
{
  const [latDict, latLabels] = latencyData;
  makeBar(latencyChart, latLabels, makeDatasets(latDict, latLabels), 'ms');
}

/* Jitter */
{
  const [jitDict, jitLabels] = jitterData;
  makeLine(jitterChart, jitLabels, makeDatasets(jitDict, jitLabels), 'ms');
}

/* Game-specific */
const titleEl = document.getElementById('gameChartTitle');
if (clickEvents) {
  titleEl.textContent = 'Clicks & Sync Markers';
  const actors = Object.keys(clickEvents);
  const clickDatasets = actors.map(a => ({
    type: 'scatter',
    label: `${a} Click`,
    data: clickEvents[a].map(t => ({ x: +t, y: actors.indexOf(a) })),
    showLine: false
  }));
  const syncDataset = {
    type: 'scatter',
    label: 'Sync',
    data: syncEvents.map(t => ({ x: +t, y: -1 })),
    pointStyle: 'triangle',
    radius: 6,
    borderColor: '#d14',
    backgroundColor: '#d14'
  };
  new Chart(gameChart, {
    data: { datasets: [...clickDatasets, syncDataset] },
    options: {
      parsing: false,
      responsive: true,
      scales: { x: { title: { display: true, text: 'Time (s)' } }, y: { display: false } }
    }
  });

} else if (frequencyData) {
  titleEl.textContent = 'Finger Frequency & Sync Intervals';
  const datasets = makeDatasets(frequencyData, frequencyLabels);
  new Chart(gameChart, {
    type: 'line',
    data: { labels: frequencyLabels, datasets },
    options: {
      responsive: true,
      scales: { y: { title: { display: true, text: 'Hz' } } },
      plugins: {
        annotation: {
          annotations: (syncIntervals || []).map(([start, end]) => ({
            type: 'box', xMin: start, xMax: end, backgroundColor: 'rgba(180,180,180,0.15)'
          }))
        }
      }
    },
    plugins: [Chart.registry.getPlugin('annotation')]
  });
} else {
  titleEl.textContent = '(No game-specific data)';
}

/* Fullscreen dblclick */
document.querySelectorAll('.chart-container').forEach(c => {
  c.addEventListener('dblclick', () => {
    if (!document.fullscreenElement) {
      (c.requestFullscreen || c.webkitRequestFullscreen || c.mozRequestFullScreen || c.msRequestFullscreen).call(c);
    } else {
      (document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen).call(document);
    }
  });
});
</script>
</body>
</html>

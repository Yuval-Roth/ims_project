<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Single Session Data</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Stylesheets -->
  <link rel="stylesheet" href="{{ url_for('static', filename='general.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='session_data.css') }}">

  <!-- Chart.js (core + zoom only) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>

  <style>
    .charts-grid {
      display: flex;
      flex-direction: column;
      gap: 50px;
      align-items: center;
      margin: 40px auto;
    }
    .chart-container {
      width: 90vw;
      max-width: 1200px;
      height: 420px;
      position: relative;
    }
    .chart-container:fullscreen {
      width: 100vw;
      height: 100vh;
      background: #fff;
      padding: 12px;
      box-sizing: border-box;
    }
  </style>
</head>
<body>
<a href="/session_data" class="home-button">
  <img src="{{ url_for('static', filename='photos/home.png') }}" alt="Home" class="home-icon">
</a>

<div class="session-container">
  <h1>Session ID: #{{ metadata.sessionId }}</h1>
  <p style="text-align:center;">
    <strong>Game Type:</strong> {{ metadata.gameType.replace('_',' ').title() }} |
    <strong>Duration:</strong> {{ metadata.duration }} s |
    <strong>Participants:</strong> {{ metadata.participants|join(' & ') }}
  </p>

  <div class="charts-grid">
    <div class="chart-container">
      <h3 style="text-align:center;" id="gameChartTitle"></h3>
      <canvas id="gameChart"></canvas>
      <!-- Reset button will be injected here dynamically -->
    </div>
    {% if data.angle_data %}
      <div class="chart-container">
        <h3 style="text-align:center;">Finger Angle</h3>
        <canvas id="angleChart"></canvas>
      </div>
    {% endif %}
    <div class="chart-container">
      <h3 style="text-align:center;">Heart Rate</h3>
      <canvas id="hrChart"></canvas>
    </div>
    <div class="chart-container">
      <h3 style="text-align:center;">HR Variation</h3>
      <canvas id="hrvChart"></canvas>
    </div>
    <div class="chart-container">
      <h3 style="text-align:center;">Latency</h3>
      <canvas id="latencyChart"></canvas>
    </div>
    <div class="chart-container">
      <h3 style="text-align:center;">Jitter</h3>
      <canvas id="jitterChart"></canvas>
    </div>
  </div>
</div>

<script>
/**** ---------- GLOBAL SPEED-UPS ---------- ****/
Chart.defaults.animation = false;
Chart.defaults.elements.line.tension = 0;

/**** ---------- DATA FROM FLASK ---------- ****/
const meta          = {{ metadata|tojson }};
const heartData     = {{ data.heart|tojson }};
const hrvData       = {{ data.hrv|tojson }};
const latencyData   = {{ data.latency|tojson }};
const jitterData    = {{ data.jitter|tojson }};
const clickEvents   = {{ data.click_events|tojson }};
const syncEvents    = {{ data.sync_events|tojson }};
const frequencyData = {{ data.frequency_data|tojson }};
const syncIntervals = {{ data.sync_intervals|tojson }};
const angleData     = {{ data.angle_data|tojson }};

/**** ---------- HELPERS ---------- ****/
function clampAxesToZero(chart) {
  // Clamp X-axis
  const xScale = chart.scales.x;
  if (xScale.min < 0) {
    const spanX = xScale.max - xScale.min;
    xScale.options.min = 0;
    xScale.options.max = spanX;
  }
  // Clamp Y-axis
  const yScale = chart.scales.y;
  if (yScale.min < 0) {
    const spanY = yScale.max - yScale.min;
    yScale.options.min = 0;
    yScale.options.max = spanY;
  }
  chart.update('none'); // redraw with clamped axes
}

function fullscreenZoom(chartRef) {
  let isPanning = false;
  let startX, startY;
  const canvas = chartRef.canvas;

  canvas.addEventListener('mousedown', e => {
    if (e.button === 0) {
      isPanning = true;
      startX = e.clientX;
      startY = e.clientY;
      canvas.style.cursor = 'grabbing';
    }
  });

  canvas.addEventListener('mouseup', e => {
    if (e.button === 0) {
      isPanning = false;
      canvas.style.cursor = 'default';
    }
  });

  canvas.addEventListener('mousemove', e => {
    if (!isPanning) return;
    const deltaX = e.clientX - startX;
    const deltaY = e.clientY - startY;

    chartRef.pan({ x: -deltaX, y: -deltaY }, undefined, 'default');
    clampAxesToZero(chartRef);

    startX = e.clientX;
    startY = e.clientY;
  });

  canvas.addEventListener('wheel', e => {
    // Ctrl+wheel = zoom Y; otherwise zoom X
    chartRef.options.plugins.zoom.zoom.mode = e.ctrlKey ? 'y' : 'x';
  }, { passive: true });

  return {
    pan: {
      enabled: false,
      rangeMin: { x: 0, y: 0 }
    },
    zoom: {
      wheel: {
        enabled: true,
        speed: 0.1,
        onZoom: ({ chart }) => {
          clampAxesToZero(chart);
        }
      },
      pinch: {
        enabled: true,
        mode: 'xy'
      },
      mode: 'x',
      limits: {
        x: { min: 0 },
        y: { min: 0 }
      }
    }
  };
}

function dictToDatasets(dict, extra = {}) {
  return Object.keys(dict).map(actor => ({
    label: actor,
    data: dict[actor].timestamps.map((t, i) => ({ x: +t, y: +dict[actor].values[i] })),
    pointRadius: 3,
    fill: false,
    ...extra
  }));
}

/**** ---------- GENERIC LINE-CHART BUILDER ---------- ****/
function makeLineChart(id, datasets, yLabel, yOpts = {}) {
  const ctx = document.getElementById(id);
  const chart = new Chart(ctx, {
    type: 'line',
    data: { datasets },
    options: {
      parsing: false,
      responsive: true,
      scales: {
        x: {
          type: 'linear',
          title: { display: true, text: 'Time (s)' }
        },
        y: {
          title: { display: true, text: yLabel },
          ...yOpts
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => ${ctx.dataset.label}: ${ctx.parsed.y}
          }
        }
      }
    }
  });

  chart.options.plugins.zoom = fullscreenZoom(chart);
  chart.update();

  addResetZoomButton(chart, ctx.parentElement);
}

/**** ---------- METRIC CHARTS ---------- ****/
makeLineChart('hrChart', dictToDatasets(heartData), 'BPM');
makeLineChart('hrvChart', dictToDatasets(hrvData), 'ms');
makeLineChart('latencyChart', dictToDatasets(latencyData), 'ms');
makeLineChart('jitterChart', dictToDatasets(jitterData), 'ms');

/**** ---------- CLICK-/SYNC OR FREQUENCY VIEW ---------- ****/
const titleEl = document.getElementById('gameChartTitle');
const COLORS = ['#007bff', '#dc3545'];
const SYNC_COLOR = '#ffca2c';
const BAND_SPACING = 0.10;
const LINE_HALF = 0.07;

function bandCenter(idx) {
  return idx === 0 ? 0.5 - BAND_SPACING : 0.5 + BAND_SPACING;
}
function bandMin(idx) {
  return bandCenter(idx) - LINE_HALF;
}
function bandMax(idx) {
  return bandCenter(idx) + LINE_HALF;
}

// Fast vertical ticks plugin for clicks view
const fastTicks = {
  id: 'fastTicks',
  afterDraw(chart) {
    if (chart.canvas.id !== 'gameChart') return;
    if (!clickEvents || !Object.keys(clickEvents).length) return;
    const actors = Object.keys(clickEvents).sort().slice(0, 2);
    const ctx = chart.ctx,
          xS = chart.scales.x,
          yS = chart.scales.y;

    actors.forEach((actor, idx) => {
      if (chart.getDatasetMeta(idx).hidden) return;
      ctx.strokeStyle = COLORS[idx];
      ctx.lineWidth = 3;
      ctx.beginPath();
      (clickEvents[actor] || []).forEach(t => {
        const px = xS.getPixelForValue(+t);
        ctx.moveTo(px, yS.getPixelForValue(bandMin(idx)));
        ctx.lineTo(px, yS.getPixelForValue(bandMax(idx)));
      });
      ctx.stroke();
    });

    if (!chart.getDatasetMeta(2)?.hidden && syncEvents?.length) {
      ctx.strokeStyle = SYNC_COLOR;
      ctx.lineWidth = 2;
      ctx.beginPath();
      syncEvents.forEach(t => {
        const px = xS.getPixelForValue(+t);
        ctx.moveTo(px, yS.getPixelForValue(bandMax(0)));
        ctx.lineTo(px, yS.getPixelForValue(bandMin(1)));
      });
      ctx.stroke();
    }
  }
};
Chart.register(fastTicks);

// Grey sync-interval boxes plugin for frequency view
const syncBoxes = {
  id: 'syncBoxes',
  beforeDraw(chart) {
    if (chart.canvas.id !== 'gameChart' || chart.config.type !== 'line') return;
    if (!syncIntervals?.length) return;
    const ctx = chart.ctx,
          xS = chart.scales.x,
          yS = chart.scales.y;
    ctx.save();
    ctx.fillStyle = 'rgba(180,180,180,0.15)';
    syncIntervals.forEach(([s, e]) => {
      const x0 = xS.getPixelForValue(+s),
            x1 = xS.getPixelForValue(+e);
      ctx.fillRect(x0, yS.top, x1 - x0, yS.bottom - yS.top);
    });
    ctx.restore();
  }
};
Chart.register(syncBoxes);

if (Object.keys(clickEvents || {}).length) {
  titleEl.textContent = 'Clicks & Sync Markers';
  const actors = Object.keys(clickEvents).sort();
  const topData    = (clickEvents[actors[0]] || []).map(t => ({ x: +t, y: bandCenter(0) }));
  const bottomData = (clickEvents[actors[1]] || []).map(t => ({ x: +t, y: bandCenter(1) }));
  const syncData   = (syncEvents || []).map(t => ({ x: +t, y: 0.5 }));

  const legendSets = [
    {
      label: ${actors[0] || 'P1'} Click,
      showLine: false,
      data: topData.length ? topData : [{ x: 0, y: bandCenter(0) }],
      pointRadius: 0,
      borderColor: COLORS[0]
    },
    {
      label: ${actors[1] || 'P2'} Click,
      showLine: false,
      data: bottomData.length ? bottomData : [{ x: 0, y: bandCenter(1) }],
      pointRadius: 0,
      borderColor: COLORS[1]
    },
    {
      label: 'Sync',
      showLine: false,
      data: syncData.length ? syncData : [{ x: 0, y: 0.5 }],
      pointRadius: 0,
      borderColor: SYNC_COLOR
    }
  ];

  const gameCtx = document.getElementById('gameChart');
  const gameChart = new Chart(gameCtx, {
    type: 'scatter',
    data: { datasets: legendSets },
    options: {
      parsing: false,
      responsive: true,
      scales: {
        x: {
          type: 'linear',
          title: { display: true, text: 'Time (s)' }
        },
        y: {
          display: false,
          min: 0,
          max: 1
        }
      },
      plugins: {
        tooltip: { enabled: false },
        legend: { labels: { usePointStyle: true } }
      }
    }
  });

  // Attach clamp‐aware zoom config and add reset button
  gameChart.options.plugins.zoom = fullscreenZoom(gameChart);
  gameChart.update();
  addResetZoomButton(gameChart, gameCtx.parentElement);

} else if (frequencyData && Object.keys(frequencyData).length) {
  titleEl.textContent = 'Finger Frequency & Sync Intervals';
  const freqSets = Object.keys(frequencyData).map(a => ({
    label: a,
    data: frequencyData[a].timestamps.map((t, i) => {
      const v = +frequencyData[a].values[i];
      return { x: +t, y: v === 0 ? null : v };
    }),
    pointRadius: 0,
    fill: false
  }));

  const freqCtx = document.getElementById('gameChart');
  const gameChart = new Chart(freqCtx, {
    type: 'line',
    data: { datasets: freqSets },
    options: {
      parsing: false,
      responsive: true,
      scales: {
        x: {
          type: 'linear',
          title: { display: true, text: 'Time (s)' }
        },
        y: {
          title: { display: true, text: 'Hz' }
        }
      },
      plugins: {
        tooltip: {
          callbacks: { label: ctx => ${ctx.dataset.label}: ${ctx.parsed.y} }
        }
      }
    }
  });

  // Attach clamp‐aware zoom config and add reset button
  gameChart.options.plugins.zoom = fullscreenZoom(gameChart);
  gameChart.update();
  addResetZoomButton(gameChart, freqCtx.parentElement);

} else {
  titleEl.textContent = '(No game-specific data)';
}

/**** ---------- ANGLE CHART (shown only when angleData exists) ---------- ****/
if (angleData && Object.keys(angleData).length) {
  function rescaleY(chart) {
    const { min: xMin, max: xMax } = chart.scales.x;
    let yMin = Infinity, yMax = -Infinity;

    chart.data.datasets.forEach(ds => {
      ds.data.forEach(pt => {
        if (pt.x >= xMin && pt.x <= xMax) {
          yMin = Math.min(yMin, pt.y);
          yMax = Math.max(yMax, pt.y);
        }
      });
    });

    if (yMin !== Infinity) {
      const PAD = 5;
      chart.options.scales.y.min = Math.floor(yMin - PAD);
      chart.options.scales.y.max = Math.ceil(yMax + PAD);
      chart.update('none');
    }
  }

  const angleCtx = document.getElementById('angleChart');
  const angleChart = new Chart(angleCtx, {
    type: 'scatter',
    data: {
      datasets: Object.keys(angleData).map(actor => ({
        label: actor,
        data: angleData[actor].timestamps.map((t, i) => ({ x: +t, y: +angleData[actor].values[i] })),
        pointRadius: 3
      }))
    },
    options: {
      parsing: false,
      responsive: true,
      scales: {
        x: { type: 'linear', title: { display: true, text: 'Time (s)' } },
        y: { title: { display: true, text: 'Angle (°)' }, min: -180, max: 180 }
      },
      plugins: {
        tooltip: { callbacks: { label: ctx => ${ctx.dataset.label}: ${ctx.parsed.y} } }
      }
    }
  });

  // Attach clamp‐aware zoom config
  angleChart.options.plugins.zoom = fullscreenZoom(angleChart);

  // After zoom/pan, clamp both axes then rescale Y
  angleChart.options.plugins.zoom.zoom.onZoomComplete = ({ chart }) => {
    clampAxesToZero(chart);
    rescaleY(chart);
  };
  angleChart.options.plugins.zoom.zoom.onPanComplete = ({ chart }) => {
    clampAxesToZero(chart);
    rescaleY(chart);
  };

  angleChart.update();
  addResetZoomButton(angleChart, angleCtx.parentElement);
}

function addResetZoomButton(chart, container) {
  const btn = document.createElement('button');
  btn.textContent = 'Reset Zoom';
  btn.className = 'reset-btn';
  btn.addEventListener('click', () => {
    chart.resetZoom();
  });
  container.appendChild(btn);
}

/**** ---------- dbl-click → fullscreen ---------- ****/
document.querySelectorAll('.chart-container').forEach(container => {
  const canvas = container.querySelector('canvas');
  canvas.addEventListener('dblclick', () => {
    if (document.fullscreenElement) {
      document.exitFullscreen();
    } else {
      container.requestFullscreen();
    }
  });
});
</script>
</body>
</html>

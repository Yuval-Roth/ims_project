<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Single Session Data</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="{{ url_for('static', filename='general.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='session_data.css') }}">

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>

  <style>
    .charts-grid { display:flex; flex-direction:column; gap:50px; align-items:center; margin:40px auto; }
    .chart-container { width:90vw; max-width:1200px; height:420px; position:relative; }
    .chart-container:fullscreen { width:100vw;height:100vh;background:#fff;padding:12px;box-sizing:border-box; }
  </style>
</head>

<body>
<a href="/session_data" class="home-button">
  <img src="{{ url_for('static', filename='photos/home.png') }}" alt="Home" class="home-icon">
</a>

<div class="session-container">
  <h1>Session ID: #{{ metadata.sessionId }}</h1>
  <p style="text-align:center;">
    <strong>Game Type:</strong> {{ metadata.gameType.replace('_',' ').title() }} |
    <strong>Duration:</strong> {{ metadata.duration }} s |
    <strong>Participants:</strong> {{ metadata.participants|join(' & ') }}
  </p>

  <div class="charts-grid">
    <div class="chart-container"><h3 style="text-align:center;" id="gameChartTitle"></h3><canvas id="gameChart"></canvas></div>
    <div class="chart-container"><h3 style="text-align:center;">Heart Rate</h3><canvas id="hrChart"></canvas></div>
    <div class="chart-container"><h3 style="text-align:center;">HR Variation</h3><canvas id="hrvChart"></canvas></div>
    <div class="chart-container"><h3 style="text-align:center;">Latency</h3><canvas id="latencyChart"></canvas></div>
    <div class="chart-container"><h3 style="text-align:center;">Jitter</h3><canvas id="jitterChart"></canvas></div>
  </div>
</div>

<script>
/* ---------------------------------------------------------------
 *                Chart.js helpers & utilities
 * ------------------------------------------------------------- */
Chart.register(
  Chart.registry.getPlugin('annotation'),
  Chart.registry.getPlugin('zoom')
);

const meta          = {{ metadata|tojson }};
const heartData     = {{ data.heart|tojson }};
const hrvData       = {{ data.hrv|tojson }};
const latencyData   = {{ data.latency|tojson }};
const jitterData    = {{ data.jitter|tojson }};
const clickEvents   = {{ data.click_events|tojson }};
const syncEvents    = {{ data.sync_events|tojson }};
const frequencyData = {{ data.frequency_data|tojson }};
const syncIntervals = {{ data.sync_intervals|tojson }};

function fullscreenZoom() {
  return {
    zoom:{ wheel:{enabled:true}, pinch:{enabled:true}, mode:'x' },
    pan:{enabled:false}
  };
}
function dictToDatasets(dict, extra={}) {
  return Object.keys(dict).map(actor => ({
    label:actor,
    data:dict[actor].timestamps.map((t,i)=>({x:+t, y:+dict[actor].values[i]})),
    pointRadius:3, tension:.3, fill:false, ...extra
  }));
}
function makeLineChart(canvasId, datasets, yLabel){
  new Chart(document.getElementById(canvasId),{
    type:'line',
    data:{datasets},
    options:{
      parsing:false, responsive:true,
      scales:{
        x:{type:'linear',title:{display:true,text:'Time (s)'}},
        y:{title:{display:true,text:yLabel}}
      },
      plugins:{ tooltip:{callbacks:{label:ctx=>`${ctx.dataset.label}: ${ctx.parsed.y}`}},
                zoom:fullscreenZoom() }
    }
  });
}

/* ---------------------------------------------------------------
 *                   Metric charts (unchanged)
 * ------------------------------------------------------------- */
makeLineChart('hrChart'     , dictToDatasets(heartData)                          , 'BPM');
makeLineChart('hrvChart'    , dictToDatasets(hrvData)                           , 'ms');
makeLineChart('latencyChart', dictToDatasets(latencyData,{pointRadius:0,tension:.4,backgroundColor:'rgba(60,150,255,.08)',fill:'origin'}), 'ms');
makeLineChart('jitterChart' , dictToDatasets(jitterData)                         , 'ms');

/* ---------------------------------------------------------------
 *             Clicks & Sync Markers (tighter vertical spacing)
 * ------------------------------------------------------------- */
const titleEl   = document.getElementById('gameChartTitle');
const RED       = '#dc3545';
const BLUE      = '#007bff';
const GOLD      = '#ffca2c';

/* --- tweak these two to control look & feel ------------------- */
const BAND_SPACING = 0.10;   // distance of click-band centres from 0.5
const LINE_HALF    = 0.07;   // Â½-thickness of each coloured stroke
/* -------------------------------------------------------------- */

const TOP_CENTER    = 0.5 + BAND_SPACING;
const BOTTOM_CENTER = 0.5 - BAND_SPACING;
const TOP_MIN       = TOP_CENTER    - LINE_HALF;
const TOP_MAX       = TOP_CENTER    + LINE_HALF;
const BOTTOM_MIN    = BOTTOM_CENTER - LINE_HALF;
const BOTTOM_MAX    = BOTTOM_CENTER + LINE_HALF;

if (clickEvents) {
  titleEl.textContent = 'Clicks & Sync Markers';
  const actors  = Object.keys(clickEvents).sort();
  const topA    = actors[0] || 'A';
  const bottomA = actors[1] || 'B';

  const annotations = [];

  (clickEvents[topA]||[]).forEach(t => annotations.push({
    type:'line', xMin:+t, xMax:+t, yMin:TOP_MIN, yMax:TOP_MAX,
    borderColor:RED, borderWidth:4
  }));
  (clickEvents[bottomA]||[]).forEach(t => annotations.push({
    type:'line', xMin:+t, xMax:+t, yMin:BOTTOM_MIN, yMax:BOTTOM_MAX,
    borderColor:BLUE, borderWidth:4
  }));
  (syncEvents||[]).forEach(t => annotations.push({
    type:'line', xMin:+t, xMax:+t, yMin:BOTTOM_MAX, yMax:TOP_MIN,
    borderColor:GOLD, borderWidth:2
  }));

  const scatterSets = [
    { label:`${topA} Click`, showLine:false,
      data:(clickEvents[topA]||[]).map(t=>({x:+t,y:TOP_CENTER})),
      pointRadius:0, hitRadius:10 },

    { label:`${bottomA} Click`, showLine:false,
      data:(clickEvents[bottomA]||[]).map(t=>({x:+t,y:BOTTOM_CENTER})),
      pointRadius:0, hitRadius:10 },

    { label:'Sync', showLine:false,
      data:(syncEvents||[]).map(t=>({x:+t,y:0.5})),
      pointRadius:0, hitRadius:10 }
  ];

  const gChart = new Chart(document.getElementById('gameChart'),{
    type:'scatter',
    data:{datasets:scatterSets},
    options:{
      parsing:false, responsive:true,
      scales:{
        x:{type:'linear',title:{display:true,text:'Time (s)'}},
        y:{display:false,min:0,max:1}
      },
      plugins:{
        annotation:{annotations},
        tooltip:{callbacks:{label:ctx=>`${ctx.dataset.label}: ${ctx.parsed.x.toFixed(2)}s`}},
        legend:{
          labels:{usePointStyle:true},
          onClick(e,item){
            const meta  = gChart.getDatasetMeta(item.datasetIndex);
            meta.hidden = !meta.hidden;
            const label = item.text;
            annotations.forEach(a=>{
              const matchSync = label==='Sync'            && a.borderColor===GOLD;
              const matchTop  = label.includes(topA)      && a.borderColor===RED;
              const matchBot  = label.includes(bottomA)   && a.borderColor===BLUE;
              if (matchSync||matchTop||matchBot) a.display = !meta.hidden;
            });
            gChart.update();
          }
        },
        zoom:fullscreenZoom()
      }
    }
  });

} else if (frequencyData) {
  titleEl.textContent = 'Finger Frequency & Sync Intervals';
  new Chart(document.getElementById('gameChart'), {
    type: 'line',
    data: { datasets: dictToDatasets(frequencyData, { pointRadius: 0 }) },
    options: {
      parsing: false,
      responsive: true,
      scales: {
        x: { type: 'linear', title: { display: true, text: 'Time (s)' } },
        y: { title: { display: true, text: 'Hz' } }
      },
      plugins: {
        annotation: {
          annotations: (syncIntervals || []).map(([s, e]) => ({
            type: 'box',
            xMin: s,
            xMax: e,
            yScaleID: 'y',
            backgroundColor: 'rgba(180,180,180,0.15)'
          }))
        },
        tooltip: {
          callbacks: { label: ctx => `${ctx.dataset.label}: ${ctx.parsed.y}` }
        },
        zoom: {
          zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'x' },
          pan: { enabled: true, mode: 'x' }
        }
      }
    }
  });
}

/* double-click any chart to toggle true fullscreen */
document.querySelectorAll('.chart-container').forEach(c=>{
  c.addEventListener('dblclick',()=>{
    (document.fullscreenElement) ? document.exitFullscreen() : c.requestFullscreen();
  });
});
</script>
</body>
</html>
